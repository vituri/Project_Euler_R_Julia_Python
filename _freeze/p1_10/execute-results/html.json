{
  "hash": "45ff476d3e964c98f9d439829d95e8f2",
  "result": {
    "markdown": "# Problems 1-10\n\n## Prelude\n\nFunctions shared among some exercises.\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n# define a function that give prime numbers up to n\nfunction sieve_of_eratosthenes(n::Integer)\n  sieve = trues(n)  # Create a boolean array to mark primes\n  \n  # Set the multiples of primes as false (not prime)\n  for i in 2:isqrt(n)\n    if sieve[i]\n      for j in i^2:i:n\n        sieve[j] = false\n      end\n    end\n  end\n  \n  primes = filter(x -> sieve[x], 2:n)  # Filter out non-primes\n  \n  return primes\nend;\n```\n:::\n\n\n\n## Problem 1\n\n::: {.callout-note icon=false}\n## Problem\n\n<p>If we list all the natural numbers below $10$ that are multiples of $3$ or $5$, we get $3, 5, 6$ and $9$. The sum of these multiples is $23$.</p>\n<p>Find the sum of all the multiples of $3$ or $5$ below $1000$.</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p1()\n  [x for x ∈ 1:999 if (x % 3 == 0 || x % 5 == 0)] |> sum\nend;\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 5 evaluations.\n Range (min … max):  6.040 μs … 678.121 μs  ┊ GC (min … max): 0.00% … 96.88%\n Time  (median):     7.347 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   8.224 μs ±  12.687 μs  ┊ GC (mean ± σ):  4.00% ±  2.69%\n\n  ▂▅█▄                                                         \n  ████▅▃▂▄▅▆▇▇▅▄▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  6.04 μs         Histogram: frequency by time        16.9 μs <\n\n Memory estimate: 7.61 KiB, allocs estimate: 6.\n```\n:::\n:::\n\n\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = function() {\n  \n  sequencia_numeros = seq(999)\n  mult_3 = NULL\n  mult_5 = NULL\n  \n  for (i in sequencia_numeros) {\n    \n    if(i %% 3 == 0) {\n      \n      mult_3 = c(mult_3, i)\n      \n    } else if (i %% 5 == 0) {\n      \n      mult_5 = c(mult_5, i)\n      \n    }\n    \n  }\n  \n  return(sum(c(mult_3, mult_5)))\n  \n}\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p1())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p1()          548µs    648µs     1403.     269KB     20.9\n```\n:::\n:::\n\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = function(){\n  soma = 0\n  \n  for (numero in 1:999) {\n    if(numero %% 3 == 0 || numero %% 5 == 0){\n      soma = soma + numero\n    }\n  }\n  return(soma)\n}\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p1())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p1()          289µs    343µs     2673.        0B     33.5\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef p1(n = 1000):\n  return sum([x for x in range(n) if x % 3 == 0 or x % 5 == 0]);\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# p1()\n```\n:::\n\n\n## Problem 2\n::: {.callout-note icon=false}\n## Problem\n\n<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:\n$1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\dots$</p>\n<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p2()\n  # start with the first 2 terms\n  fibo = [1, 2]\n  \n  # while smaller than 4_000_000, keep adding\n  while true\n    current_fibo_term = fibo[end] + fibo[end - 1]\n    if current_fibo_term < 4_000_000\n      push!(fibo, current_fibo_term)\n    else \n      break\n    end        \n  end\n  \n  # sum the results\n  return [x for x ∈ fibo if iseven(x)] |> sum\nend;\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n  1+1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 176 evaluations.\n Range (min … max):  605.938 ns … 31.875 μs  ┊ GC (min … max): 0.00% … 97.05%\n Time  (median):     731.423 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   885.255 ns ±  1.423 μs  ┊ GC (mean ± σ):  9.46% ±  5.95%\n\n  ▂▂▄▅▇█▇▆▅▅▄▄▃▃▃▂▂▁▁▁▁▁▁▁▁▁ ▁                                 ▂\n  ███████████████████████████████████▇██▇▇▇▆▆▅▅▅▅▅▅▄▅▅▅▅▅▄▆▄▄▃ █\n  606 ns        Histogram: log(frequency) by time       1.8 μs <\n\n Memory estimate: 1.02 KiB, allocs estimate: 7.\n```\n:::\n:::\n\n\n### Julia (optimized)\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p2()\n    a, b = 1, 2\n    sum = 2\n    while true\n        current_fibo_term = a + b\n        current_fibo_term > 4_000_000 && break\n        iseven(current_fibo_term) && (sum += current_fibo_term)\n        a, b = b, current_fibo_term\n    end\n    return sum\nend;\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 995 evaluations.\n Range (min … max):  23.205 ns … 61.933 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     25.423 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   26.584 ns ±  3.627 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▁ ▇▂▆▃█▆▄▇▃▂▄  ▁▁ ▂  ▁  ▁   ▂   ▂▂▁▁ ▂                      ▂\n  █▂███████████▇███▇█▇▆█▆▇█▇▆▇██████████▇▇▆▇▆▆▆▅▅▆▅▅▅▄▄▄▄▄▄▅▅ █\n  23.2 ns      Histogram: log(frequency) by time      42.3 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n```\n:::\n:::\n\n\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\np2 = function() {\n  ultimofibo = 2\n  soma = 2\n  \n  L = list()\n  L[[1]] = 1\n  L[[2]] = 2\n  i = 3\n  while(ultimofibo <= 4000000){\n    \n    L[[i]] = L[[i - 1]] + L[[i - 2]]\n    \n    ultimofibo = L[[i]]\n    i = i + 1\n    \n    if(ultimofibo%%2 == 0){\n      soma = soma + ultimofibo\n    }\n  }\n  \n  soma\n}\n\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p2())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p2()         23.6µs   28.3µs    31834.    2.37KB     15.9\n```\n:::\n:::\n\n\n### R (optimized)\n\n::: {.cell}\n\n```{.r .cell-code}\np2 = function() {\n  ultimofibo = 2\n  valor = 2\n  x0 = 1\n  x1 = 2\n  \n  while (ultimofibo < 4000000) {\n    x2 = x0 + x1\n    ultimofibo = x2\n    x0 = x1\n    x1 = x2\n    if(ultimofibo %% 2 == 0){\n      if (ultimofibo < 4000000){\n        valor = valor + ultimofibo \n      }\n    }\n  }\n  \n  valor\n}\n\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p2())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p2()         7.29µs   8.78µs   101338.        0B     10.1\n```\n:::\n:::\n\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef p2(roof = 4 * 10 ** 6):\n  fibo = [1,2]\n  while True:\n    fibo = fibo + [fibo[-1] + fibo[-2]]\n    if fibo[-1] > roof:\n      break\n    return sum([x for x in fibo if x % 2  == 0])\n  \n  # def p2(roof = 4 * 10 ** 6):\n  #     a, b = 1, 2\n  #     even_sum = 0\n  #     while True:\n  #         if b % 2 == 0:\n  #             even_sum += b\n  #         a, b = b, a + b\n  #         if b > roof:\n  #             break\n  #     return even_sum\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n  # %timeit p2()\n```\n:::\n\n  \n## Problem 3\n::: {.callout-note icon=false}\n## Problem\n  \n<p>The prime factors of $13195$ are $5, 7, 13$ and $29$.</p>\n<p>What is the largest prime factor of the number $600851475143$?</p>\n:::\n  \n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p3()\n  n = 600851475143\n  \n  # get all primes lesses than sqrt(n)\n  possible_primes = sieve_of_eratosthenes(isqrt(n)) # see prelude\n  \n  # get the biggest one\n  id = findlast(x -> n % x == 0, possible_primes)    \n  return possible_primes[id]\nend;\n\np3()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6857\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p3()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 887 samples with 1 evaluation.\n Range (min … max):  4.330 ms …  10.458 ms  ┊ GC (min … max): 0.00% … 8.41%\n Time  (median):     5.289 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   5.622 ms ± 939.890 μs  ┊ GC (mean ± σ):  1.44% ± 3.29%\n\n       ▄▇▆██▇▆▆▄▄▄▃▄▃▃▁▂▂▁ ▂▁▁                                ▁\n  ▅▁▅▅▆███████████████████████▇▆▆▆▄▇▅▇▅▅▇▁▅▆▆▇▄▅▁▅▄▁▁▆▅▅▆▄▁▁▆ █\n  4.33 ms      Histogram: log(frequency) by time       9.5 ms <\n\n Memory estimate: 6.48 MiB, allocs estimate: 8.\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# trying without https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\nimport math\n\ndef p3(n):\n    \n    larger_prime_divisor = None\n    for lesser in range(int(n / 2 // 1), 1, -1):\n        \n        divides = n % lesser == 0\n        if divides:\n            \n            # a quick test if 'lesser' is not prime\n            if (lesser - 1) % 6 > 0:\n                if (lesser + 1) % 6 > 0:\n                    if lesser not in [2,3]:\n                        continue\n            \n            # decide if 'lesser' is prime by definition,\n            # but using the fact that the greatest prime divisor of 'lesser',\n            # if it is not 'lesser' itself and it exists, cannot be\n            # greater than sqrt(lesser)\n            # print(lesser)\n            is_prime = True            \n            j = 2\n            floor = math.sqrt(lesser)\n            # floor = lesser / 2 // 1\n            while j <= floor:\n                # print('   ' + str(j))\n                is_prime = not lesser % j == 0\n                if not is_prime:\n                    break\n                j += 1\n            \n            if is_prime:\n                larger_prime_divisor = lesser\n                break\n    \n    if larger_prime_divisor == None:\n        larger_prime_divisor = n\n    \n    return larger_prime_divisor\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# %timeit p3(600851475143)\nprint('not optimized just yet!')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnot optimized just yet!\n```\n:::\n:::\n\n\n## Problem 4\n      \n::: {.callout-note icon=false}\n## Problem\n\n<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two $2$-digit numbers is $9009 = 91 \\times 99$.</p>\n<p>Find the largest palindrome made from the product of two $3$-digit numbers.</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction is_palindrome(s::AbstractString)\n    l = length(s)\n\n    for i ∈ 1:fld(l, 2)\n        s[i] != s[l + 1 - i] && return false        \n    end\n\n    return true\nend;\n\nis_palindrome(n::Integer) = is_palindrome(string(n));\n\nfunction p4()\n  a, b, largest_palindrome = 0, 0, 0\n  \n  for x ∈ reverse(100:999)\n      for y ∈ reverse(100:999)\n          x < y && continue\n          p = x * y\n          p < largest_palindrome && break # we can break the inner loop, because the next product is going to be even lesser\n          if is_palindrome(p)\n            a, b, largest_palindrome = x, y, p \n          end\n      end\n  end\n\n  # if no palindrome was found:\n  return (a, b, a*b)\nend;\n\np4()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(993, 913, 906609)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p4()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 5716 samples with 1 evaluation.\n Range (min … max):  702.190 μs …   8.075 ms  ┊ GC (min … max): 0.00% … 82.86%\n Time  (median):     799.785 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   867.108 μs ± 383.069 μs  ┊ GC (mean ± σ):  4.37% ±  8.45%\n\n  ▃▆█▆▄▃▂▂                                                      ▁\n  █████████████▇▇▇▇▇██▅▅▄▄▄▃▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▆ █\n  702 μs        Histogram: log(frequency) by time       2.97 ms <\n\n Memory estimate: 526.28 KiB, allocs estimate: 12248.\n```\n:::\n:::\n\n\n\n## Problem 5\n      \n::: {.callout-note icon=false}\n## Problem\n\n<p>$2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.</p>\n<p>What is the smallest positive number that is <dfn class=\"tooltip\">evenly divisible<span class=\"tooltiptext\">divisible with no remainder</span></dfn> by all of the numbers from $1$ to $20$?</p>\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction prime_decomposition(n::Integer)\n    possible_primes = sieve_of_eratosthenes(n)\n    temp_n = n\n    dec = Int32[]\n\n    while temp_n > 1\n        for p ∈ possible_primes\n            q, r = divrem(temp_n, p)            \n            if iszero(r)\n                temp_n = temp_n ÷ p\n                push!(dec, p)\n                break\n            end\n        end\n    end\n    return dec\nend;\n\nfunction p5()\n    decomposition = map(prime_decomposition, 2:20)\n    distinct_primes = vcat(decomposition...) |> unique\n\n    count_matrix = \n    map(distinct_primes) do p\n        map(decomposition) do d\n            count(==(p), d)\n        end\n    end |> stack\n\n    primes_powers = map(maximum, eachcol(count_matrix))\n\n    n = (distinct_primes .^ primes_powers) |> prod\n\n    return n\nend;\n\np5()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n232792560\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p5()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  11.932 μs …  3.506 ms  ┊ GC (min … max): 0.00% … 98.60%\n Time  (median):     14.041 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   15.946 μs ± 35.124 μs  ┊ GC (mean ± σ):  2.17% ±  0.99%\n\n    ▄▄▆█▄                                                      \n  ▃██████▆▆▅▄▄▄▃▄▃▃▃▃▃▂▃▃▂▂▂▂▂▂▂▂▂▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  11.9 μs         Histogram: frequency by time        31.3 μs <\n\n Memory estimate: 12.67 KiB, allocs estimate: 143.\n```\n:::\n:::\n\n\n\n## Problem 6\n      \n::: {.callout-note icon=false}\n## Problem\n\n<p> The sum of the squares of the first ten natural numbers is\n$1^2+ 2 ^2+ \\dots + 10^2 = 385.$</p>\n<p>The square of the sum of the first ten natural numbers is\n$(1+ 2+ \\dots + 10)^2 = 3025.$</p>\n</p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025-385 = 2640.$</p>\n\n</p> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. </p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p6()\n  sum(1:100)^2 - sum((1:100).^2)\nend;\np6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25164150\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 937 evaluations.\n Range (min … max):  104.475 ns …   2.010 μs  ┊ GC (min … max): 0.00% … 76.54%\n Time  (median):     141.991 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   199.576 ns ± 169.768 ns  ┊ GC (mean ± σ):  8.42% ± 10.07%\n\n  █▆                                                             \n  ██▆▅▅▄▄▃▃▃▄▄▄▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▁▂▁▁▂▁▁▁▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃\n  104 ns           Histogram: frequency by time         1.05 μs <\n\n Memory estimate: 896 bytes, allocs estimate: 1.\n```\n:::\n:::\n\n\n\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\np6 = function(){\n  S1 =0\n  S2 = 0\n  \n  for(i in 1:100){\n    S1 = S1+i**2\n    S2 = S2+i\n  }\n  S2 = S2**2\n  \n  S1\n  S2\n  return(S2-S1)\n}\n\np6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25164150\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p6())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p6()         5.09µs   5.95µs   157975.        0B        0\n```\n:::\n:::\n\n\n### R (shorter)\n\n::: {.cell}\n\n```{.r .cell-code}\np6 = function() {\n  sum(1:100)^2 - sum((1:100)^2)\n}\n\np6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25164150\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p6())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p6()         1.34µs   1.69µs   449163.    32.3KB        0\n```\n:::\n:::\n\n\n## Problem 7\n\n::: {.callout-note icon=false}\n## Problem\n      \n<p>By listing the first six prime numbers: $2, 3, 5, 7, 11$, and $13$, we can see that the $6$th prime is $13$.</p>\n<p>What is the $10\\,001$st prime number?</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nis_divisible_by(n::Integer, q::Integer) = n % q == 0;\n\nfunction find_next_prime(primes)\n    n = primes[end]\n    while true        \n        n += 2\n\n        not_prime = false\n    \n        for q ∈ primes\n            not_prime = is_divisible_by(n, q)\n            if not_prime\n                break                \n            end            \n        end\n\n        if not_prime \n            continue \n        end\n    \n        return(n)        \n    end    \nend;\n\nfunction find_n_primes(n::Integer)\n    primes = [2, 3]\n    while length(primes) < n\n        next_prime = find_next_prime(primes)\n        push!(primes, next_prime)\n    end\n\n    return primes\nend;\n\np7() = find_n_primes(10_001)[end];\np7()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n104743\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p7()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 33 samples with 1 evaluation.\n Range (min … max):  148.535 ms … 193.663 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     152.722 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   155.040 ms ±   8.789 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n       █                                                         \n  ▃▁▃▇▇█▇▅▃▃▁▁▁▃▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃ ▁\n  149 ms           Histogram: frequency by time          194 ms <\n\n Memory estimate: 326.56 KiB, allocs estimate: 9.\n```\n:::\n:::\n\n\n## Problem 8\n\n::: {.callout-note icon=false}\n## Problem\n      \n<p>The four adjacent digits in the $1000$-digit number that have the greatest product are $9 \\times 9 \\times 8 \\times 9 = 5832$.</p>\n<p class=\"monospace center\">\n73167176531330624919225119674426574742355349194934<br>\n96983520312774506326239578318016984801869478851843<br>\n85861560789112949495459501737958331952853208805511<br>\n12540698747158523863050715693290963295227443043557<br>\n66896648950445244523161731856403098711121722383113<br>\n62229893423380308135336276614282806444486645238749<br>\n30358907296290491560440772390713810515859307960866<br>\n70172427121883998797908792274921901699720888093776<br>\n65727333001053367881220235421809751254540594752243<br>\n52584907711670556013604839586446706324415722155397<br>\n53697817977846174064955149290862569321978468622482<br>\n83972241375657056057490261407972968652414535100474<br>\n82166370484403199890008895243450658541227588666881<br>\n16427171479924442928230863465674813919123162824586<br>\n17866458359124566529476545682848912883142607690042<br>\n24219022671055626321111109370544217506941658960408<br>\n07198403850962455444362981230987879927244284909188<br>\n84580156166097919133875499200524063689912560717606<br>\n05886116467109405077541002256983155200055935729725<br>\n71636269561882670428252483600823257530420752963450<br></p>\n<p>Find the thirteen adjacent digits in the $1000$-digit number that have the greatest product. What is the value of this product?</p>\n:::\n      \n### Julia\n      \n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p8()\n  big_string = \"73167176531330624919225119674426574742355349194934\n      96983520312774506326239578318016984801869478851843\n      85861560789112949495459501737958331952853208805511\n      12540698747158523863050715693290963295227443043557\n      66896648950445244523161731856403098711121722383113\n      62229893423380308135336276614282806444486645238749\n      30358907296290491560440772390713810515859307960866\n      70172427121883998797908792274921901699720888093776\n      65727333001053367881220235421809751254540594752243\n      52584907711670556013604839586446706324415722155397\n      53697817977846174064955149290862569321978468622482\n      83972241375657056057490261407972968652414535100474\n      82166370484403199890008895243450658541227588666881\n      16427171479924442928230863465674813919123162824586\n      17866458359124566529476545682848912883142607690042\n      24219022671055626321111109370544217506941658960408\n      07198403850962455444362981230987879927244284909188\n      84580156166097919133875499200524063689912560717606\n      05886116467109405077541002256983155200055935729725\n      71636269561882670428252483600823257530420752963450\" |> filter(isnumeric) # keep only numeric characters\n  \n  biggest_product = 0\n  winner_string = \"\"\n  amount_of_digits = 13\n  \n  for i in (amount_of_digits + 1):length(big_string)\n    current_string = collect(big_string[i-amount_of_digits : i])\n    \n    p = map(x -> parse(Int32, x), current_string) |> prod\n    if p > biggest_product\n      biggest_product = p\n      winner_string = current_string\n    end\n  end\n  \n  return reduce(*, winner_string), biggest_product\nend;\n\np8()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(\"97536978179778\", 70573265280)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p8()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  332.812 μs …   4.294 ms  ┊ GC (min … max): 0.00% … 88.45%\n Time  (median):     381.313 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   404.021 μs ± 176.453 μs  ┊ GC (mean ± σ):  2.98% ±  6.12%\n\n            █▄                                                   \n  ▁▁▁▁▁▂▂▆█▅███▇▆▆▅▄▃▃▃▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  333 μs           Histogram: frequency by time          577 μs <\n\n Memory estimate: 249.06 KiB, allocs estimate: 3000.\n```\n:::\n:::\n\n\n## Problem 9\n\n::: {.callout-note icon=false}\n## Problem\n\n<p>A Pythagorean triplet is a set of three natural numbers, $a \\lt b \\lt c$, for which,\n$a^2 + b^2 = c^2.$</p>\n<p>For example, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$.</p>\n<p>There exists exactly one Pythagorean triplet for which $a + b + c = 1000$.<br>Find the product $abc$.</p>\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p9()\n    for a ∈ 1:999\n        for b ∈ 1:999            \n            c = 1000 - a - b\n            c >= 1 || continue\n            a^2 + b^2 == c^2 || continue                        \n            return a, b, c\n        end\n    end\nend;\n\np9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(200, 375, 425)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  123.904 μs … 284.551 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     138.118 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   139.406 μs ±  12.284 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n    ▂ ▃ ▆▇▂█▃▃▄▁▁▂▁▁▁                                           ▂\n  ▇▃█▇█▆████████████████▇▇▇▇▅▆▇▅▅▅▇▆▅▅▄▆▅▅▁▆▇▄▄▅▃▅▁▃▁▄▄▆▄▅▄▆▄▄▆ █\n  124 μs        Histogram: log(frequency) by time        214 μs <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n```\n:::\n:::\n\n\n### Julia (using JuMP)\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing JuMP; using SCIP;\n\nfunction p9()\n  model = Model(SCIP.Optimizer)\n  set_silent(model)\n  @variable(model, a >= 1, Int)\n  @variable(model, b >= 1, Int)\n  @variable(model, c >= 1, Int)\n  @objective(model, Min, a)\n  @constraint(model, pitagorean, a^2 + b^2 == c^2)\n  @constraint(model, sum_1000, a + b + c == 1000)  \n  optimize!(model)    \n  return value(a), value(b), value(c)\nend;\np9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(200.0, 375.0, 425.0)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 41 samples with 1 evaluation.\n Range (min … max):  103.285 ms … 217.614 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     117.181 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   123.525 ms ±  20.993 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▂█ ▅ ▅  ▂                                                     \n  ▅██▅███▅▅███▅█▁▁▅█▅▁▁▁▁▅▁▅▁▁▁▁▅▁▅▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅ ▁\n  103 ms           Histogram: frequency by time          218 ms <\n\n Memory estimate: 116.59 KiB, allocs estimate: 5097.\n```\n:::\n:::\n\n\n## Problem 10\n\n::: {.callout-note icon=false}\n## Problem\n\n<p>The sum of the primes below $10$ is $2 + 3 + 5 + 7 = 17$.</p>\n<p>Find the sum of all the primes below two million.</p>\n:::\n\n### Julia\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p10()\n  sieve_of_eratosthenes(2_000_000) |> sum\nend;\np10()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n142913828922\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p10()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 427 samples with 1 evaluation.\n Range (min … max):   9.943 ms … 22.344 ms  ┊ GC (min … max): 0.00% … 9.02%\n Time  (median):     11.161 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   11.701 ms ±  1.768 ms  ┊ GC (mean ± σ):  2.68% ± 3.76%\n\n   █▂▂▁▅▇▁                                                     \n  ▄████████▇█▆▆▄▆▅▄▄▄▃▄▃▄▃▃▃▃▃▁▃▁▂▁▃▁▂▂▂▂▁▁▁▁▂▁▁▁▁▁▁▁▁▁▂▁▁▂▁▂ ▃\n  9.94 ms         Histogram: frequency by time        20.5 ms <\n\n Memory estimate: 16.63 MiB, allocs estimate: 8.\n```\n:::\n:::\n",
    "supporting": [
      "p1_10_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}