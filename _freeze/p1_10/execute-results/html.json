{
  "hash": "8ef24c7333bc14f05eef534bc87c89a4",
  "result": {
    "markdown": "# Problems 1-10\n\n## Prelude\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\n# define a function that give prime numbers up to n\nfunction sieve_of_eratosthenes(n::Integer)\n  sieve = trues(n)  # Create a boolean array to mark primes\n  \n  # Set the multiples of primes as false (not prime)\n  for i in 2:isqrt(n)\n    if sieve[i]\n      for j in i^2:i:n\n        sieve[j] = false\n      end\n    end\n  end\n  \n  primes = filter(x -> sieve[x], 2:n)  # Filter out non-primes\n  \n  return primes\nend;\n```\n:::\n\n\n\n## Problem 1\n\n::: {.callout-note icon=false}\n## Problem\n\n<p>If we list all the natural numbers below $10$ that are multiples of $3$ or $5$, we get $3, 5, 6$ and $9$. The sum of these multiples is $23$.</p>\n<p>Find the sum of all the multiples of $3$ or $5$ below $1000$.</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p1()\n  [x for x ∈ 1:999 if (x % 3 == 0 || x % 5 == 0)] |> sum\nend;\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 6 evaluations.\n Range (min … max):  5.016 μs … 225.126 μs  ┊ GC (min … max): 0.00% … 93.49%\n Time  (median):     5.494 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   6.026 μs ±   5.296 μs  ┊ GC (mean ± σ):  2.36% ±  2.66%\n\n   ▁▅▄▆▅█▆▆▄▂▁▁      ▁▁▂▁▃▂▂▁         ▁▁▁▁▁ ▁                 ▂\n  ██████████████▇▅▇▇██████████▇▇▇▇▇▇██████████████▇▇▆▇▇▇▆▆▅▆▇ █\n  5.02 μs      Histogram: log(frequency) by time      9.16 μs <\n\n Memory estimate: 7.61 KiB, allocs estimate: 6.\n```\n:::\n:::\n\n\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = function() {\n  \n  sequencia_numeros = seq(999)\n  mult_3 = NULL\n  mult_5 = NULL\n  \n  for (i in sequencia_numeros) {\n    \n    if(i %% 3 == 0) {\n      \n      mult_3 = c(mult_3, i)\n      \n    } else if (i %% 5 == 0) {\n      \n      mult_5 = c(mult_5, i)\n      \n    }\n    \n  }\n  \n  return(sum(c(mult_3, mult_5)))\n  \n}\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p1())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p1()          482µs    525µs     1890.     269KB     27.3\n```\n:::\n:::\n\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = function(){\n  soma = 0\n  \n  for (numero in 1:999) {\n    if(numero %% 3 == 0 || numero %% 5 == 0){\n      soma = soma + numero\n    }\n  }\n  return(soma)\n}\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p1())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p1()          262µs    288µs     3458.        0B     45.2\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef p1(n = 1000):\n  return sum([x for x in range(n) if x % 3 == 0 or x % 5 == 0]);\n\np1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n233168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# p1()\n```\n:::\n\n\n## Problem 2\n::: {.callout-note icon=false}\n## Problem\n\n<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:\n$1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\dots$</p>\n<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p2()\n  # start with the first 2 terms\n  fibo = [1, 2]\n  \n  # while smaller than 4_000_000, keep adding\n  while true\n    current_fibo_term = fibo[end] + fibo[end - 1]\n    if current_fibo_term < 4_000_000\n      push!(fibo, current_fibo_term)\n    else \n      break\n    end        \n  end\n  \n  # sum the results\n  return [x for x ∈ fibo if iseven(x)] |> sum\nend;\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n  1+1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 190 evaluations.\n Range (min … max):  516.042 ns …  16.744 μs  ┊ GC (min … max): 0.00% … 95.55%\n Time  (median):     574.489 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   633.959 ns ± 824.292 ns  ┊ GC (mean ± σ):  8.48% ±  6.22%\n\n   ▁▂▃▃▆▅▅█▆▇█▆▅▅▂▂▁▁▁▂▂▂▂▁                                     ▂\n  ██████████████████████████▇▇▅▇▆▆▅▆▇▁▆▅▅▆▅▅▇▇▆▅▆██▇▇▇▇▆▃▆▆▆▁▅▅ █\n  516 ns        Histogram: log(frequency) by time        855 ns <\n\n Memory estimate: 1.02 KiB, allocs estimate: 7.\n```\n:::\n:::\n\n\n### Julia (optimized)\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p2()\n    a, b = 1, 2\n    sum = 2\n    while true\n        current_fibo_term = a + b\n        current_fibo_term > 4_000_000 && break\n        iseven(current_fibo_term) && (sum += current_fibo_term)\n        a, b = b, current_fibo_term\n    end\n    return sum\nend;\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 996 evaluations.\n Range (min … max):  20.301 ns … 58.622 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     20.890 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   21.815 ns ±  2.220 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▆  █▁ ▇  ▃▄  ▂   ▂   ▅   ▁▃   ▂    ▁    ▁     ▁     ▂       ▂\n  █▆▅██▇█▅▄██▄▆█▄▃▆█▃▄▅█▄▄▄██▄▁▁█▅▄▃▁█▃▃▃▁█▁▃▁▁▁█▁▁▃▁▁█▃▁▁▁▁█ █\n  20.3 ns      Histogram: log(frequency) by time      30.1 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n```\n:::\n:::\n\n\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\np2 = function() {\n  ultimofibo = 2\n  soma = 2\n  \n  L = list()\n  L[[1]] = 1\n  L[[2]] = 2\n  i = 3\n  while(ultimofibo <= 4000000){\n    \n    L[[i]] = L[[i - 1]] + L[[i - 2]]\n    \n    ultimofibo = L[[i]]\n    i = i + 1\n    \n    if(ultimofibo%%2 == 0){\n      soma = soma + ultimofibo\n    }\n  }\n  \n  soma\n}\n\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p2())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p2()         20.4µs   23.2µs    41700.    2.37KB     16.7\n```\n:::\n:::\n\n\n### R (optimized)\n\n::: {.cell}\n\n```{.r .cell-code}\np2 = function() {\n  ultimofibo = 2\n  valor = 2\n  x0 = 1\n  x1 = 2\n  \n  while (ultimofibo < 4000000) {\n    x2 = x0 + x1\n    ultimofibo = x2\n    x0 = x1\n    x1 = x2\n    if(ultimofibo %% 2 == 0){\n      if (ultimofibo < 4000000){\n        valor = valor + ultimofibo \n      }\n    }\n  }\n  \n  valor\n}\n\np2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4613732\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p2())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p2()         6.32µs   7.18µs   133267.        0B     26.7\n```\n:::\n:::\n\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef p2(roof = 4 * 10 ** 6):\n  fibo = [1,2]\n  while True:\n    fibo = fibo + [fibo[-1] + fibo[-2]]\n    if fibo[-1] > roof:\n      break\n    return sum([x for x in fibo if x % 2  == 0])\n  \n  # def p2(roof = 4 * 10 ** 6):\n  #     a, b = 1, 2\n  #     even_sum = 0\n  #     while True:\n  #         if b % 2 == 0:\n  #             even_sum += b\n  #         a, b = b, a + b\n  #         if b > roof:\n  #             break\n  #     return even_sum\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n  # %timeit p2()\n```\n:::\n\n  \n## Problem 3\n::: {.callout-note icon=false}\n## Problem\n  \n<p>The prime factors of $13195$ are $5, 7, 13$ and $29$.</p>\n<p>What is the largest prime factor of the number $600851475143$?</p>\n:::\n  \n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p3()\n  n = 600851475143\n  \n  # get all primes lesses than sqrt(n)\n  possible_primes = sieve_of_eratosthenes(isqrt(n)) # see prelude\n  \n  # get the biggest one\n  id = findlast(x -> n % x == 0, possible_primes)    \n  return possible_primes[id]\nend;\n\np3()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6857\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p3()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 1187 samples with 1 evaluation.\n Range (min … max):  3.804 ms …   6.091 ms  ┊ GC (min … max): 0.00% … 6.67%\n Time  (median):     4.160 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   4.212 ms ± 169.959 μs  ┊ GC (mean ± σ):  1.22% ± 2.77%\n\n                     ▇▅▆▄█▆▃▁▆▃                                \n  ▂▁▂▁▁▁▁▂▁▁▂▂▂▂▂▂▃▂▄██████████▆▄▃▂▃▂▁▁▂▁▁▂▁▂▂▂▃▃▄▄▅▄▅▃▃▃▂▃▁▂ ▃\n  3.8 ms          Histogram: frequency by time        4.66 ms <\n\n Memory estimate: 6.48 MiB, allocs estimate: 8.\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# trying without https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\nimport math\n\ndef p3(n):\n    \n    larger_prime_divisor = None\n    for lesser in range(int(n / 2 // 1), 1, -1):\n        \n        divides = n % lesser == 0\n        if divides:\n            \n            # a quick test if 'lesser' is not prime\n            if (lesser - 1) % 6 > 0:\n                if (lesser + 1) % 6 > 0:\n                    if lesser not in [2,3]:\n                        continue\n            \n            # decide if 'lesser' is prime by definition,\n            # but using the fact that the greatest prime divisor of 'lesser',\n            # if it is not 'lesser' itself and it exists, cannot be\n            # greater than sqrt(lesser)\n            # print(lesser)\n            is_prime = True            \n            j = 2\n            floor = math.sqrt(lesser)\n            # floor = lesser / 2 // 1\n            while j <= floor:\n                # print('   ' + str(j))\n                is_prime = not lesser % j == 0\n                if not is_prime:\n                    break\n                j += 1\n            \n            if is_prime:\n                larger_prime_divisor = lesser\n                break\n    \n    if larger_prime_divisor == None:\n        larger_prime_divisor = n\n    \n    return larger_prime_divisor\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# %timeit p3(600851475143)\nprint('not optimized just yet!')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnot optimized just yet!\n```\n:::\n:::\n\n\n## Problem 4\n      \n::: {.callout-note icon=false}\n## Problem\n\n<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two $2$-digit numbers is $9009 = 91 \\times 99$.</p>\n<p>Find the largest palindrome made from the product of two $3$-digit numbers.</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction is_palindrome(s::AbstractString)\n    l = length(s)\n\n    for i ∈ 1:fld(l, 2)\n        s[i] != s[l + 1 - i] && return false        \n    end\n\n    return true\nend;\n\nis_palindrome(n::Integer) = is_palindrome(string(n));\n\nfunction p4()\n    for x ∈ reverse(100:999)\n        for y ∈ reverse(100:999)\n            p = x * y\n            if is_palindrome(p) \n                return(x, y, p)\n            end\n        end\n    end\n\n    # if no palindrome was found:\n    return (0, 0, 0)\nend;\n\np4()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(995, 583, 580085)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p4()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  252.408 μs …   3.145 ms  ┊ GC (min … max): 0.00% … 90.03%\n Time  (median):     287.522 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   309.734 μs ± 232.921 μs  ┊ GC (mean ± σ):  6.60% ±  7.87%\n\n                ▁▃█▅  ▁▃                                         \n  ▂▂▂▃▃▃▂▃▃▂▃▃▃▃████▇▅██▅▄▄▄▃▃▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▂▂▂▁▂▂▂▂▂▁▂▂▂▂▂▂▂▂ ▃\n  252 μs           Histogram: frequency by time          376 μs <\n\n Memory estimate: 345.21 KiB, allocs estimate: 8034.\n```\n:::\n:::\n\n\n\n## Problem 5\n      \n::: {.callout-note icon=false}\n## Problem\n\n<p>$2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.</p>\n<p>What is the smallest positive number that is <dfn class=\"tooltip\">evenly divisible<span class=\"tooltiptext\">divisible with no remainder</span></dfn> by all of the numbers from $1$ to $20$?</p>\n:::\n\n## Problem 6\n      \n::: {.callout-note icon=false}\n## Problem\n\n<p> The sum of the squares of the first ten natural numbers is\n$1^2+ 2 ^2+ \\dots + 10^2 = 385.$</p>\n<p>The square of the sum of the first ten natural numbers is\n$(1+ 2+ \\dots + 10)^2 = 3025.$</p>\n</p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025-385 = 2640.$</p>\n\n</p> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. </p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p6()\n  sum(1:100)^2 - sum((1:100).^2)\nend;\np6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25164150\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 952 evaluations.\n Range (min … max):   87.890 ns …  1.018 μs  ┊ GC (min … max): 0.00% … 64.28%\n Time  (median):     105.294 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   121.561 ns ± 77.070 ns  ┊ GC (mean ± σ):  6.98% ±  9.56%\n\n  ▂█▆▆▃▁▁                                                      ▁\n  ████████▇▆▆▇▅▅▅▆▇▅▄▁▁▁▁▁▁▃▆▅▄▆▅▅▅▅▅▃▁▁▁▁▁▁▁▁▁▁▁▃▁▃▄▆▅▆▆▅▆▆▆▆ █\n  87.9 ns       Histogram: log(frequency) by time       642 ns <\n\n Memory estimate: 896 bytes, allocs estimate: 1.\n```\n:::\n:::\n\n\n\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\np6 = function(){\n  S1 =0\n  S2 = 0\n  \n  for(i in 1:100){\n    S1 = S1+i**2\n    S2 = S2+i\n  }\n  S2 = S2**2\n  \n  S1\n  S2\n  return(S2-S1)\n}\n\np6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25164150\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p6())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p6()         4.53µs   5.19µs   179415.        0B     17.9\n```\n:::\n:::\n\n\n### R (shorter)\n\n::: {.cell}\n\n```{.r .cell-code}\np6 = function() {\n  sum(1:100)^2 - sum((1:100)^2)\n}\n\np6()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25164150\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(p6())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 p6()         1.14µs    1.4µs   609672.    32.3KB        0\n```\n:::\n:::\n\n\n## Problem 7\n\n::: {.callout-note icon=false}\n## Problem\n      \n<p>By listing the first six prime numbers: $2, 3, 5, 7, 11$, and $13$, we can see that the $6$th prime is $13$.</p>\n<p>What is the $10\\,001$st prime number?</p>\n:::\n\n### Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nis_divisible_by(n::Integer, q::Integer) = n % q == 0;\n\nfunction find_next_prime(primes)\n    n = primes[end]\n    while true        \n        n += 2\n\n        not_prime = false\n    \n        for q ∈ primes\n            not_prime = is_divisible_by(n, q)\n            if not_prime\n                break                \n            end            \n        end\n\n        if not_prime \n            continue \n        end\n    \n        return(n)        \n    end    \nend;\n\nfunction find_n_primes(n::Integer)\n    primes = [2, 3]\n    while length(primes) < n\n        next_prime = find_next_prime(primes)\n        push!(primes, next_prime)\n    end\n\n    return primes\nend;\n\np7() = find_n_primes(10_001)[end];\np7()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n104743\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p7()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 36 samples with 1 evaluation.\n Range (min … max):  140.501 ms … 144.701 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     142.590 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   142.751 ms ±   1.146 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n           ▃  ▃       ▃     ▃  ▃         █    ▃      █           \n  ▇▁▁▇▁▁▁▁▁█▁▁█▁▇▁▁▁▇▁█▇▁▇▁▇█▁▇█▁▇▁▁▁▁▁▇▁█▇▁▁▁█▇▇▁▁▇▁█▁▁▇▁▇▁▁▇▇ ▁\n  141 ms           Histogram: frequency by time          145 ms <\n\n Memory estimate: 326.56 KiB, allocs estimate: 9.\n```\n:::\n:::\n\n\n## Problem 8\n\n::: {.callout-note icon=false}\n## Problem\n      \n<p>The four adjacent digits in the $1000$-digit number that have the greatest product are $9 \\times 9 \\times 8 \\times 9 = 5832$.</p>\n<p class=\"monospace center\">\n73167176531330624919225119674426574742355349194934<br>\n96983520312774506326239578318016984801869478851843<br>\n85861560789112949495459501737958331952853208805511<br>\n12540698747158523863050715693290963295227443043557<br>\n66896648950445244523161731856403098711121722383113<br>\n62229893423380308135336276614282806444486645238749<br>\n30358907296290491560440772390713810515859307960866<br>\n70172427121883998797908792274921901699720888093776<br>\n65727333001053367881220235421809751254540594752243<br>\n52584907711670556013604839586446706324415722155397<br>\n53697817977846174064955149290862569321978468622482<br>\n83972241375657056057490261407972968652414535100474<br>\n82166370484403199890008895243450658541227588666881<br>\n16427171479924442928230863465674813919123162824586<br>\n17866458359124566529476545682848912883142607690042<br>\n24219022671055626321111109370544217506941658960408<br>\n07198403850962455444362981230987879927244284909188<br>\n84580156166097919133875499200524063689912560717606<br>\n05886116467109405077541002256983155200055935729725<br>\n71636269561882670428252483600823257530420752963450<br></p>\n<p>Find the thirteen adjacent digits in the $1000$-digit number that have the greatest product. What is the value of this product?</p>\n:::\n      \n### Julia\n      \n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p8()\n  big_string = \"73167176531330624919225119674426574742355349194934\n      96983520312774506326239578318016984801869478851843\n      85861560789112949495459501737958331952853208805511\n      12540698747158523863050715693290963295227443043557\n      66896648950445244523161731856403098711121722383113\n      62229893423380308135336276614282806444486645238749\n      30358907296290491560440772390713810515859307960866\n      70172427121883998797908792274921901699720888093776\n      65727333001053367881220235421809751254540594752243\n      52584907711670556013604839586446706324415722155397\n      53697817977846174064955149290862569321978468622482\n      83972241375657056057490261407972968652414535100474\n      82166370484403199890008895243450658541227588666881\n      16427171479924442928230863465674813919123162824586\n      17866458359124566529476545682848912883142607690042\n      24219022671055626321111109370544217506941658960408\n      07198403850962455444362981230987879927244284909188\n      84580156166097919133875499200524063689912560717606\n      05886116467109405077541002256983155200055935729725\n      71636269561882670428252483600823257530420752963450\" |> filter(isnumeric) # keep only numeric characters\n  \n  biggest_product = 0\n  winner_string = \"\"\n  amount_of_digits = 13\n  \n  for i in (amount_of_digits + 1):length(big_string)\n    current_string = collect(big_string[i-amount_of_digits : i])\n    \n    p = map(x -> parse(Int32, x), current_string) |> prod\n    if p > biggest_product\n      biggest_product = p\n      winner_string = current_string\n    end\n  end\n  \n  return reduce(*, winner_string), biggest_product\nend;\n\np8()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(\"97536978179778\", 70573265280)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p8()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  344.111 μs …   1.958 ms  ┊ GC (min … max): 0.00% … 79.47%\n Time  (median):     378.443 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   388.361 μs ± 104.481 μs  ┊ GC (mean ± σ):  1.96% ±  5.75%\n\n                     ▂█▇      ▆▄                                 \n  ▂▁▁▂▂▂▁▂▂▂▂▂▃▃▃▃▃▄▅████▅▄▄▅████▅▃▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃\n  344 μs           Histogram: frequency by time          432 μs <\n\n Memory estimate: 249.06 KiB, allocs estimate: 3000.\n```\n:::\n:::\n\n\n## Problem 9\n\n::: {.callout-note icon=false}\n## Problem\n\n<p>A Pythagorean triplet is a set of three natural numbers, $a \\lt b \\lt c$, for which,\n$a^2 + b^2 = c^2.$</p>\n<p>For example, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$.</p>\n<p>There exists exactly one Pythagorean triplet for which $a + b + c = 1000$.<br>Find the product $abc$.</p>\n:::\n\n### Julia\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p9()\n    for a ∈ 1:999\n        for b ∈ 1:999            \n            c = 1000 - a - b\n            c >= 1 || continue\n            a^2 + b^2 == c^2 || continue                        \n            return a, b, c\n        end\n    end\nend;\n\np9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(200, 375, 425)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  205.912 μs … 299.591 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     230.622 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   228.887 μs ±   6.676 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▁       ▁       ▃▃▃  ▁   █▇▆▃▂▁   ▃█▇▄▃▂▁▁ ▁▂▄▃▁▁     ▁▁      ▂\n  █▃▃▁▁▁▁▆█▁▃▄▁▃▁▁███████▅▅███████▆▇███████████████████▇████▇▇█ █\n  206 μs        Histogram: log(frequency) by time        249 μs <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n```\n:::\n:::\n\n\n### Julia (using JuMP)\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing JuMP; using SCIP;\n\nfunction p9()\n  model = Model(SCIP.Optimizer)\n  set_silent(model)\n  @variable(model, a >= 1, Int)\n  @variable(model, b >= 1, Int)\n  @variable(model, c >= 1, Int)\n  @objective(model, Min, a)\n  @constraint(model, pitagorean, a^2 + b^2 == c^2)\n  @constraint(model, sum_1000, a + b + c == 1000)  \n  optimize!(model)    \n  return value(a), value(b), value(c)\nend;\np9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(200.0, 375.0, 425.0)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p9()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 49 samples with 1 evaluation.\n Range (min … max):   98.516 ms … 128.971 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     100.859 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   103.932 ms ±   6.531 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n    █▂▅                                                          \n  ▇▇███▅█▁▁▄▁▁▇▁▁▁▁▁▄▄▁▁▄▁▁▁▁▄▇▄▄▁▁▁▄▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▁\n  98.5 ms          Histogram: frequency by time          129 ms <\n\n Memory estimate: 116.59 KiB, allocs estimate: 5097.\n```\n:::\n:::\n\n\n## Problem 10\n\n::: {.callout-note icon=false}\n## Problem\n\n<p>The sum of the primes below $10$ is $2 + 3 + 5 + 7 = 17$.</p>\n<p>Find the sum of all the primes below two million.</p>\n:::\n\n### Julia\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction p10()\n  sieve_of_eratosthenes(2_000_000) |> sum\nend;\np10()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n142913828922\n```\n:::\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing BenchmarkTools;\n@benchmark p10()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 486 samples with 1 evaluation.\n Range (min … max):   9.353 ms …  12.785 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     10.168 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   10.302 ms ± 389.379 μs  ┊ GC (mean ± σ):  2.05% ± 2.79%\n\n                    ▃▅█▅▅▃▁ ▂▇                ▂ ▄               \n  ▂▁▁▂▁▁▁▂▁▁▁▁▂▁▁▁▁████████████▅▃▃▁▂▁▁▂▁▃▄▆▇▅▆████▆▄▃▂▃▃▂▂▂▁▁▂ ▃\n  9.35 ms         Histogram: frequency by time         11.2 ms <\n\n Memory estimate: 16.63 MiB, allocs estimate: 8.\n```\n:::\n:::\n",
    "supporting": [
      "p1_10_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}