# Problems 1-10

## Prelude

### Julia
```{julia}
# define a function that give prime numbers up to n
function sieve_of_eratosthenes(n::Integer)
  sieve = trues(n)  # Create a boolean array to mark primes
  
  # Set the multiples of primes as false (not prime)
  for i in 2:isqrt(n)
    if sieve[i]
      for j in i^2:i:n
        sieve[j] = false
      end
    end
  end
  
  primes = filter(x -> sieve[x], 2:n)  # Filter out non-primes
  
  return primes
end;
```


## Problem 1

::: {.callout-note icon=false}
## Problem

<p>If we list all the natural numbers below $10$ that are multiples of $3$ or $5$, we get $3, 5, 6$ and $9$. The sum of these multiples is $23$.</p>
<p>Find the sum of all the multiples of $3$ or $5$ below $1000$.</p>
:::

### Julia

```{julia}
function p1()
  [x for x ∈ 1:999 if (x % 3 == 0 || x % 5 == 0)] |> sum
end;

p1()
```

```{julia}
using BenchmarkTools;
@benchmark p1()
```


### R

```{r}
p1 = function() {
  
  sequencia_numeros = seq(999)
  mult_3 = NULL
  mult_5 = NULL
  
  for (i in sequencia_numeros) {
    
    if(i %% 3 == 0) {
      
      mult_3 = c(mult_3, i)
      
    } else if (i %% 5 == 0) {
      
      mult_5 = c(mult_5, i)
      
    }
    
  }
  
  return(sum(c(mult_3, mult_5)))
  
}

p1()
```

```{r}
bench::mark(p1())
```

### R

```{r}
p1 = function(){
  soma = 0
  
  for (numero in 1:999) {
    if(numero %% 3 == 0 || numero %% 5 == 0){
      soma = soma + numero
    }
  }
  return(soma)
}

p1()
```

```{r}
bench::mark(p1())
```

### Python

```{python}
def p1(n = 1000):
  return sum([x for x in range(n) if x % 3 == 0 or x % 5 == 0]);

p1()
```

```{python}
# p1()
```

## Problem 2
::: {.callout-note icon=false}
## Problem

<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:
$1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \dots$</p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
:::

### Julia

```{julia}
function p2()
  # start with the first 2 terms
  fibo = [1, 2]
  
  # while smaller than 4_000_000, keep adding
  while true
    current_fibo_term = fibo[end] + fibo[end - 1]
    if current_fibo_term < 4_000_000
      push!(fibo, current_fibo_term)
    else 
      break
    end        
  end
  
  # sum the results
  return [x for x ∈ fibo if iseven(x)] |> sum
end;
p2()
```



```{julia}
  1+1
```


```{julia}
using BenchmarkTools;
@benchmark p2()
```

### Julia (optimized)

```{julia}
function p2()
    a, b = 1, 2
    sum = 2
    while true
        current_fibo_term = a + b
        current_fibo_term > 4_000_000 && break
        iseven(current_fibo_term) && (sum += current_fibo_term)
        a, b = b, current_fibo_term
    end
    return sum
end;
p2()
```

```{julia}
using BenchmarkTools;
@benchmark p2()
```

### R
```{R}
p2 = function() {
  ultimofibo = 2
  soma = 2
  
  L = list()
  L[[1]] = 1
  L[[2]] = 2
  i = 3
  while(ultimofibo <= 4000000){
    
    L[[i]] = L[[i - 1]] + L[[i - 2]]
    
    ultimofibo = L[[i]]
    i = i + 1
    
    if(ultimofibo%%2 == 0){
      soma = soma + ultimofibo
    }
  }
  
  soma
}

p2()
```

```{r}
bench::mark(p2())
```

### R (optimized)
```{R}
p2 = function() {
  ultimofibo = 2
  valor = 2
  x0 = 1
  x1 = 2
  
  while (ultimofibo < 4000000) {
    x2 = x0 + x1
    ultimofibo = x2
    x0 = x1
    x1 = x2
    if(ultimofibo %% 2 == 0){
      if (ultimofibo < 4000000){
        valor = valor + ultimofibo 
      }
    }
  }
  
  valor
}

p2()
```

```{r}
bench::mark(p2())
```


### Python

```{python}
def p2(roof = 4 * 10 ** 6):
  fibo = [1,2]
  while True:
    fibo = fibo + [fibo[-1] + fibo[-2]]
    if fibo[-1] > roof:
      break
    return sum([x for x in fibo if x % 2  == 0])
```
  
```{python}
  # %timeit p2()
```

### Python (optimized)

```{python}
def p2(roof = 4 * 10 ** 6):
    a, b = 1, 2
    even_sum = 0
    while True:
        if b % 2 == 0:
            even_sum += b
        a, b = b, a + b
        if b > roof:
            break
    return even_sum
```

```{python}
  # %timeit p2()
```

  
## Problem 3
::: {.callout-note icon=false}
## Problem
  
<p>The prime factors of $13195$ are $5, 7, 13$ and $29$.</p>
<p>What is the largest prime factor of the number $600851475143$?</p>
:::
  
### Julia
```{julia}
function p3()
  n = 600851475143
  
  # get all primes lesses than sqrt(n)
  possible_primes = sieve_of_eratosthenes(isqrt(n)) # see prelude
  
  # get the biggest one
  id = findlast(x -> n % x == 0, possible_primes)    
  return possible_primes[id]
end;

p3()
```

```{julia}
using BenchmarkTools;
@benchmark p3()
```

### Python

```{python}
# trying without https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
import math

def p3(n):
    
    larger_prime_divisor = None
    for lesser in range(int(n / 2 // 1), 1, -1):
        
        divides = n % lesser == 0
        if divides:
            
            # a quick test if 'lesser' is not prime
            if (lesser - 1) % 6 > 0:
                if (lesser + 1) % 6 > 0:
                    if lesser not in [2,3]:
                        continue
            
            # decide if 'lesser' is prime by definition,
            # but using the fact that the greatest prime divisor of 'lesser',
            # if it is not 'lesser' itself and it exists, cannot be
            # greater than sqrt(lesser)
            # print(lesser)
            is_prime = True            
            j = 2
            floor = math.sqrt(lesser)
            # floor = lesser / 2 // 1
            while j <= floor:
                # print('   ' + str(j))
                is_prime = not lesser % j == 0
                if not is_prime:
                    break
                j += 1
            
            if is_prime:
                larger_prime_divisor = lesser
                break
    
    if larger_prime_divisor == None:
        larger_prime_divisor = n
    
    return larger_prime_divisor
```
      
```{python}
# %timeit p3(600851475143)
print('not optimized just yet!')
```

## Problem 4
      
::: {.callout-note icon=false}
## Problem

<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two $2$-digit numbers is $9009 = 91 \times 99$.</p>
<p>Find the largest palindrome made from the product of two $3$-digit numbers.</p>
:::

### Julia

```{julia}
function is_palindrome(s::AbstractString)
    l = length(s)

    for i ∈ 1:fld(l, 2)
        s[i] != s[l + 1 - i] && return false        
    end

    return true
end;

is_palindrome(n::Integer) = is_palindrome(string(n));

function p4()
    for x ∈ reverse(100:999)
        for y ∈ reverse(100:999)
            p = x * y
            if is_palindrome(p) 
                return(x, y, p)
            end
        end
    end

    # if no palindrome was found:
    return (0, 0, 0)
end;

p4()
```

```{julia}
using BenchmarkTools;
@benchmark p4()
```

```{python}
def is_palindrome(x):
    idx = len(str(x)) // 2
    return str(x)[:idx] == str(x)[-idx:][::-1]

def p4():
    three_digits = range(100, 1000, 1)
    for i in three_digits:
        for j in three_digits:
            prod = i * j
            if is_palindrome(prod):
                return prod, i, j
    
    return None
```

```{python}
# %timeit p4()
```

## Problem 5
      
::: {.callout-note icon=false}
## Problem

<p>$2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.</p>
<p>What is the smallest positive number that is <dfn class="tooltip">evenly divisible<span class="tooltiptext">divisible with no remainder</span></dfn> by all of the numbers from $1$ to $20$?</p>
:::

### Python

```{python}
import math
import itertools

def evenly_divisible(x, y):
    return x % y == 0

# def evenly_divisible_map(x, roof):
#     return all(map(evenly_divisible, np.repeat(x, roof), range(1, roof + 1)))
# 
# def p5(roof = 20):
#     x = roof
#     while True:
#         if evenly_divisible_map(x, roof):
#             return x
#         x += 1

def p5(roof = 20, silent = True):
    # pdb.set_trace()
    seq = [1, 2]
    if not silent:
        print('  adding: 2')
        
    candidate = 3
    while True:
        
        # product two by two, then three by three, and it goes on
        for r in range(2, len(seq) + 1):   
        
            possible_combinations = itertools.combinations(seq, r)
            is_product = False
            for comb in possible_combinations:
                prod = math.prod(comb)
                
                # if the candidate is a product of numbers in sequence, we don't add it to the sequence
                if candidate == prod:
                    is_product = True
                    break
            
            if is_product:
                break
        
        # if it is not a product, take the candidate and divide it
        # by all the numbers within the sequence that divide it
        # That way, the sequence will have a subsequence of elements whose product
        # divides the candidate
        if not is_product:
            candidate_divisors = [x for x in seq if evenly_divisible(candidate, x)]
            to_add = int(candidate / math.prod(candidate_divisors))
            seq.append(to_add)
            if not silent:
                print('candidate:', candidate)
                print('  adding:', to_add)
        
        if candidate == roof:
            break
        
        candidate += 1
    
    return math.prod(seq)
```

```{python}
# %timeit p5()
```

## Problem 6
      
::: {.callout-note icon=false}
## Problem

<p> The sum of the squares of the first ten natural numbers is
$1^2+ 2 ^2+ \dots + 10^2 = 385.$</p>
<p>The square of the sum of the first ten natural numbers is
$(1+ 2+ \dots + 10)^2 = 3025.$</p>
</p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025-385 = 2640.$</p>

</p> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. </p>
:::

### Julia

```{julia}
function p6()
  sum(1:100)^2 - sum((1:100).^2)
end;
p6()
```

```{julia}
using BenchmarkTools;
@benchmark p6()
```


### R
```{r}
p6 = function(){
  S1 =0
  S2 = 0
  
  for(i in 1:100){
    S1 = S1+i**2
    S2 = S2+i
  }
  S2 = S2**2
  
  S1
  S2
  return(S2-S1)
}

p6()
```

```{r}
bench::mark(p6())
```

### R (shorter)
```{r}
p6 = function() {
  sum(1:100)^2 - sum((1:100)^2)
}

p6()
```

```{r}
bench::mark(p6())
```

### Python

```{python}
def p6(n):
    seq = range(1,n+1)
    return sum(seq)**2 - sum([math.prod(x) for x in zip(seq, seq)])
```

```{python}
# %timeit p6()
```
## Problem 7

::: {.callout-note icon=false}
## Problem
      
<p>By listing the first six prime numbers: $2, 3, 5, 7, 11$, and $13$, we can see that the $6$th prime is $13$.</p>
<p>What is the $10\,001$st prime number?</p>
:::

### Julia

```{julia}
is_divisible_by(n::Integer, q::Integer) = n % q == 0;

function find_next_prime(primes)
    n = primes[end]
    while true        
        n += 2

        not_prime = false
    
        for q ∈ primes
            not_prime = is_divisible_by(n, q)
            if not_prime
                break                
            end            
        end

        if not_prime 
            continue 
        end
    
        return(n)        
    end    
end;

function find_n_primes(n::Integer)
    primes = [2, 3]
    while length(primes) < n
        next_prime = find_next_prime(primes)
        push!(primes, next_prime)
    end

    return primes
end;

p7() = find_n_primes(10_001)[end];
p7()
```

```{julia}
using BenchmarkTools;
@benchmark p7()
```

## Problem 8

::: {.callout-note icon=false}
## Problem
      
<p>The four adjacent digits in the $1000$-digit number that have the greatest product are $9 \times 9 \times 8 \times 9 = 5832$.</p>
<p class="monospace center">
73167176531330624919225119674426574742355349194934<br>
96983520312774506326239578318016984801869478851843<br>
85861560789112949495459501737958331952853208805511<br>
12540698747158523863050715693290963295227443043557<br>
66896648950445244523161731856403098711121722383113<br>
62229893423380308135336276614282806444486645238749<br>
30358907296290491560440772390713810515859307960866<br>
70172427121883998797908792274921901699720888093776<br>
65727333001053367881220235421809751254540594752243<br>
52584907711670556013604839586446706324415722155397<br>
53697817977846174064955149290862569321978468622482<br>
83972241375657056057490261407972968652414535100474<br>
82166370484403199890008895243450658541227588666881<br>
16427171479924442928230863465674813919123162824586<br>
17866458359124566529476545682848912883142607690042<br>
24219022671055626321111109370544217506941658960408<br>
07198403850962455444362981230987879927244284909188<br>
84580156166097919133875499200524063689912560717606<br>
05886116467109405077541002256983155200055935729725<br>
71636269561882670428252483600823257530420752963450<br></p>
<p>Find the thirteen adjacent digits in the $1000$-digit number that have the greatest product. What is the value of this product?</p>
:::
      
### Julia
      
```{julia}
function p8()
  big_string = "73167176531330624919225119674426574742355349194934
      96983520312774506326239578318016984801869478851843
      85861560789112949495459501737958331952853208805511
      12540698747158523863050715693290963295227443043557
      66896648950445244523161731856403098711121722383113
      62229893423380308135336276614282806444486645238749
      30358907296290491560440772390713810515859307960866
      70172427121883998797908792274921901699720888093776
      65727333001053367881220235421809751254540594752243
      52584907711670556013604839586446706324415722155397
      53697817977846174064955149290862569321978468622482
      83972241375657056057490261407972968652414535100474
      82166370484403199890008895243450658541227588666881
      16427171479924442928230863465674813919123162824586
      17866458359124566529476545682848912883142607690042
      24219022671055626321111109370544217506941658960408
      07198403850962455444362981230987879927244284909188
      84580156166097919133875499200524063689912560717606
      05886116467109405077541002256983155200055935729725
      71636269561882670428252483600823257530420752963450" |> filter(isnumeric) # keep only numeric characters
  
  biggest_product = 0
  winner_string = ""
  amount_of_digits = 13
  
  for i in (amount_of_digits + 1):length(big_string)
    current_string = collect(big_string[i-amount_of_digits : i])
    
    p = map(x -> parse(Int32, x), current_string) |> prod
    if p > biggest_product
      biggest_product = p
      winner_string = current_string
    end
  end
  
  return reduce(*, winner_string), biggest_product
end;

p8()
```

```{julia}
using BenchmarkTools;
@benchmark p8()
```

## Problem 9

::: {.callout-note icon=false}
## Problem

<p>A Pythagorean triplet is a set of three natural numbers, $a \lt b \lt c$, for which,
$a^2 + b^2 = c^2.$</p>
<p>For example, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$.</p>
<p>There exists exactly one Pythagorean triplet for which $a + b + c = 1000$.<br>Find the product $abc$.</p>
:::

### Julia
```{julia}
function p9()
    for a ∈ 1:999
        for b ∈ 1:999            
            c = 1000 - a - b
            c >= 1 || continue
            a^2 + b^2 == c^2 || continue                        
            return a, b, c
        end
    end
end;

p9()
```

```{julia}
using BenchmarkTools;
@benchmark p9()
```

### Julia (using JuMP)
```{julia}
using JuMP; using SCIP;

function p9()
  model = Model(SCIP.Optimizer)
  set_silent(model)
  @variable(model, a >= 1, Int)
  @variable(model, b >= 1, Int)
  @variable(model, c >= 1, Int)
  @objective(model, Min, a)
  @constraint(model, pitagorean, a^2 + b^2 == c^2)
  @constraint(model, sum_1000, a + b + c == 1000)  
  optimize!(model)    
  return value(a), value(b), value(c)
end;
p9()
```

```{julia}
using BenchmarkTools;
@benchmark p9()
```

## Problem 10

::: {.callout-note icon=false}
## Problem

<p>The sum of the primes below $10$ is $2 + 3 + 5 + 7 = 17$.</p>
<p>Find the sum of all the primes below two million.</p>
:::

### Julia


```{julia}
function p10()
  sieve_of_eratosthenes(2_000_000) |> sum
end;
p10()
```


```{julia}
using BenchmarkTools;
@benchmark p10()
```
