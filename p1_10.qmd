# Problems 1-10

## Prelude

Functions shared among some exercises.

### Julia
```{julia}
# define a function that give prime numbers up to n
function sieve_of_eratosthenes(n::Integer)
  sieve = trues(n)  # Create a boolean array to mark primes
  
  # Set the multiples of primes as false (not prime)
  for i in 2:isqrt(n)
    if sieve[i]
      for j in i^2:i:n
        sieve[j] = false
      end
    end
  end
  
  primes = filter(x -> sieve[x], 2:n)  # Filter out non-primes
  
  return primes
end;
```


## Problem 1

::: {.callout-note icon=false}
## Problem

<p>If we list all the natural numbers below $10$ that are multiples of $3$ or $5$, we get $3, 5, 6$ and $9$. The sum of these multiples is $23$.</p>
<p>Find the sum of all the multiples of $3$ or $5$ below $1000$.</p>
:::

### Julia

```{julia}
function p1()
  [x for x ∈ 1:999 if (x % 3 == 0 || x % 5 == 0)] |> sum
end;

p1()
```

```{julia}
using BenchmarkTools;
@benchmark p1()
```

### Julia (faster)

```{julia}
function p1()
    s = 0
    for i ∈ 1:999
        (i % 3 == 0) || (i % 5 == 0) || continue
        s += i
    end
    return s
end;

p1()
```

```{julia}
using BenchmarkTools
@benchmark p1()
```

### R

```{r}
p1 = function() {
  
  sequencia_numeros = seq(999)
  mult_3 = NULL
  mult_5 = NULL
  
  for (i in sequencia_numeros) {
    
    if(i %% 3 == 0) {
      
      mult_3 = c(mult_3, i)
      
    } else if (i %% 5 == 0) {
      
      mult_5 = c(mult_5, i)
      
    }
    
  }
  
  return(sum(c(mult_3, mult_5)))
  
}

p1()
```

```{r}
bench::mark(p1())
```

### R

```{r}
p1 = function(){
  soma = 0
  
  for (numero in 1:999) {
    if(numero %% 3 == 0 || numero %% 5 == 0){
      soma = soma + numero
    }
  }
  return(soma)
}

p1()
```

```{r}
bench::mark(p1())
```

### Python

```{python}
def p1(n = 1000):
  return sum([x for x in range(n) if x % 3 == 0 or x % 5 == 0]);

p1()
```

```{python}
# p1()
```

## Problem 2
::: {.callout-note icon=false}
## Problem

<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:
$1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \dots$</p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
:::

### Julia

```{julia}
function p2()
  # start with the first 2 terms
  fibo = [1, 2]
  
  # while smaller than 4_000_000, keep adding
  while true
    current_fibo_term = fibo[end] + fibo[end - 1]
    if current_fibo_term < 4_000_000
      push!(fibo, current_fibo_term)
    else 
      break
    end        
  end
  
  # sum the results
  return [x for x ∈ fibo if iseven(x)] |> sum
end;
p2()
```



```{julia}
  1+1
```


```{julia}
using BenchmarkTools;
@benchmark p2()
```

### Julia (optimized)

```{julia}
function p2()
    a, b = 1, 2
    sum = 2
    while true
        current_fibo_term = a + b
        current_fibo_term > 4_000_000 && break
        iseven(current_fibo_term) && (sum += current_fibo_term)
        a, b = b, current_fibo_term
    end
    return sum
end;
p2()
```

```{julia}
using BenchmarkTools;
@benchmark p2()
```

### R
```{R}
p2 = function() {
  ultimofibo = 2
  soma = 2
  
  L = list()
  L[[1]] = 1
  L[[2]] = 2
  i = 3
  while(ultimofibo <= 4000000){
    
    L[[i]] = L[[i - 1]] + L[[i - 2]]
    
    ultimofibo = L[[i]]
    i = i + 1
    
    if(ultimofibo%%2 == 0){
      soma = soma + ultimofibo
    }
  }
  
  soma
}

p2()
```

```{r}
bench::mark(p2())
```

### R (optimized)
```{R}
p2 = function() {
  ultimofibo = 2
  valor = 2
  x0 = 1
  x1 = 2
  
  while (ultimofibo < 4000000) {
    x2 = x0 + x1
    ultimofibo = x2
    x0 = x1
    x1 = x2
    if(ultimofibo %% 2 == 0){
      if (ultimofibo < 4000000){
        valor = valor + ultimofibo 
      }
    }
  }
  
  valor
}

p2()
```

```{r}
bench::mark(p2())
```


### Python

```{python}
def p2(roof = 4 * 10 ** 6):
  fibo = [1,2]
  while True:
    fibo = fibo + [fibo[-1] + fibo[-2]]
    if fibo[-1] > roof:
      break
    return sum([x for x in fibo if x % 2  == 0])
```
  
```{python}
p2()
```

### Python (optimized)

```{python}
def p2(roof = 4 * 10 ** 6):
    a, b = 1, 2
    even_sum = 0
    while True:
        if b % 2 == 0:
            even_sum += b
        a, b = b, a + b
        if b > roof:
            break
    return even_sum
```

```{python}
p2()
```

  
## Problem 3
::: {.callout-note icon=false}
## Problem
  
<p>The prime factors of $13195$ are $5, 7, 13$ and $29$.</p>
<p>What is the largest prime factor of the number $600851475143$?</p>
:::
  
### Julia
```{julia}
function p3()
  n = 600851475143
  
  # get all primes lesses than sqrt(n)
  possible_primes = sieve_of_eratosthenes(isqrt(n)) # see prelude
  
  # get the biggest one
  id = findlast(x -> n % x == 0, possible_primes)    
  return possible_primes[id]
end;

p3()
```

```{julia}
using BenchmarkTools;
@benchmark p3()
```

### Python

```{python}
# trying without https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
import math

def p3(n):
    
    larger_prime_divisor = None
    for lesser in range(int(n / 2 // 1), 1, -1):
        
        divides = n % lesser == 0
        if divides:
            
            # a quick test if 'lesser' is not prime
            if (lesser - 1) % 6 > 0:
                if (lesser + 1) % 6 > 0:
                    if lesser not in [2,3]:
                        continue
            
            # decide if 'lesser' is prime by definition,
            # but using the fact that the greatest prime divisor of 'lesser',
            # if it is not 'lesser' itself and it exists, cannot be
            # greater than sqrt(lesser)
            # print(lesser)
            is_prime = True            
            j = 2
            floor = math.sqrt(lesser)
            # floor = lesser / 2 // 1
            while j <= floor:
                # print('   ' + str(j))
                is_prime = not lesser % j == 0
                if not is_prime:
                    break
                j += 1
            
            if is_prime:
                larger_prime_divisor = lesser
                break
    
    if larger_prime_divisor == None:
        larger_prime_divisor = n
    
    return larger_prime_divisor
```
      
```{python}
# p3(600851475143)
print('not optimized just yet!')
```

## Problem 4
      
::: {.callout-note icon=false}
## Problem

<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two $2$-digit numbers is $9009 = 91 \times 99$.</p>
<p>Find the largest palindrome made from the product of two $3$-digit numbers.</p>
:::

### Julia

```{julia}
function is_palindrome(s::AbstractString)
    l = length(s)

    for i ∈ 1:fld(l, 2)
        s[i] != s[l + 1 - i] && return false        
    end

    return true
end;

is_palindrome(n::Integer) = is_palindrome(string(n));

function p4()
  a, b, largest_palindrome = 0, 0, 0
  
  for x ∈ reverse(100:999)
      for y ∈ reverse(100:999)
          x < y && continue
          p = x * y
          p < largest_palindrome && break # we can break the inner loop, because the next product is going to be even lesser
          if is_palindrome(p)
            a, b, largest_palindrome = x, y, p 
          end
      end
  end

  # if no palindrome was found:
  return (a, b, a*b)
end;

p4()
```

```{julia}
using BenchmarkTools;
@benchmark p4()
```

### R

```{r}
palindrome = function(n){
  n = as.character(n)
  
  r = n |> strsplit("") |> unlist() |> rev() |> paste(collapse = "")
  
  r == n
}

p4= function(){
largest_palindrome = 0
a = 0
b =0

for(i in 999:100){
  for(j in 999:i){
    n= i*j
    if(n<largest_palindrome) break
    if(palindrome(n)){
      largest_palindrome =n
      a=i
      b=j}
  }
}

return(list(largest_palindrome, a, b))
}

p4()
```

```{r}
bench::mark(p4())
```

### Python
```{python}
def is_palindrome(x):
    idx = len(str(x)) // 2
    return str(x)[:idx] == str(x)[-idx:][::-1]

def p4():
    greatest, g_i, g_j = 0, 0, 0
    three_digits = range(999, 99, -1)
    for i in three_digits:
        for j in three_digits:
            prod = i * j
            if prod > greatest:
                if is_palindrome(prod):
                    greatest, g_i, g_j = prod, i, j
            else:
                continue
    
    return greatest, g_i, g_j
```

```{python}
# %timeit p4()
```

## Problem 5
      
::: {.callout-note icon=false}
## Problem

<p>$2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.</p>
<p>What is the smallest positive number that is <dfn class="tooltip">evenly divisible<span class="tooltiptext">divisible with no remainder</span></dfn> by all of the numbers from $1$ to $20$?</p>
:::

### Julia (using lcm)
```{julia}
p5() = lcm(1:20...);
p5()
```

```{julia}
using BenchmarkTools;
@benchmark p5()
```


### Julia
```{julia}
function prime_decomposition(n::Integer)
    possible_primes = sieve_of_eratosthenes(n)
    temp_n = n
    dec = Int32[]

    while temp_n > 1
        for p ∈ possible_primes
            q, r = divrem(temp_n, p)            
            if iszero(r)
                temp_n = temp_n ÷ p
                push!(dec, p)
                break
            end
        end
    end
    return dec
end;

function p5()
    decomposition = map(prime_decomposition, 2:20)
    distinct_primes = vcat(decomposition...) |> unique

    count_matrix = 
    map(distinct_primes) do p
        map(decomposition) do d
            count(==(p), d)
        end
    end |> stack

    primes_powers = map(maximum, eachcol(count_matrix))

    n = (distinct_primes .^ primes_powers) |> prod

    return n
end;

p5()
```

```{julia}
using BenchmarkTools;
@benchmark p5()
```


### Python

```{python}
import math
import itertools

def evenly_divisible(x, y):
    return x % y == 0

# def evenly_divisible_map(x, roof):
#     return all(map(evenly_divisible, np.repeat(x, roof), range(1, roof + 1)))
# 
# def p5(roof = 20):
#     x = roof
#     while True:
#         if evenly_divisible_map(x, roof):
#             return x
#         x += 1

def p5(roof = 20, silent = True):
    # pdb.set_trace()
    
    if roof < 3:
        return roof
    
    seq = [2]
    if not silent:
        print('  adding: 2')
        
    candidate = 3
    while True:
        
        if not evenly_divisible(candidate, math.prod(seq)):
        
        # product two by two, then three by three, and it goes on
            for r in range(1, len(seq) + 1):   
            
                possible_combinations = itertools.combinations(seq, r)
                is_product = False
                for comb in possible_combinations:
                    prod = math.prod(comb)
                    
                    # if the candidate is a product of numbers in sequence, we don't add it to the sequence
                    if candidate == prod:
                        is_product = True
                        break
                
                if is_product:
                    break
            
            # if it is not a product, take the candidate and divide it
            # by all the numbers within the sequence that divide it
            # That way, the sequence will have a subsequence of elements whose product
            # divides the candidate
            if not is_product:
                candidate_divisors = [x for x in seq if evenly_divisible(candidate, x)]
                to_add = int(candidate / math.prod(candidate_divisors))
                seq.append(to_add)
                if not silent:
                    print('candidate:', candidate)
                    print('  adding:', to_add)
        
        if candidate == roof:
            break
        
        candidate += 1
    
    return math.prod(seq)
```

```{python}
# p5()
```

## Problem 6
      
::: {.callout-note icon=false}
## Problem

<p> The sum of the squares of the first ten natural numbers is
$1^2+ 2 ^2+ \dots + 10^2 = 385.$</p>
<p>The square of the sum of the first ten natural numbers is
$(1+ 2+ \dots + 10)^2 = 3025.$</p>
</p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025-385 = 2640.$</p>

</p> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. </p>
:::

### Julia

```{julia}
function p6()
  sum(1:100)^2 - sum((1:100).^2)
end;
p6()
```

```{julia}
using BenchmarkTools;
@benchmark p6()
```


### R
```{r}
p6 = function(){
  S1 =0
  S2 = 0
  
  for(i in 1:100){
    S1 = S1+i**2
    S2 = S2+i
  }
  S2 = S2**2
  
  S1
  S2
  return(S2-S1)
}

p6()
```

```{r}
bench::mark(p6())
```

### R (shorter)
```{r}
p6 = function() {
  sum(1:100)^2 - sum((1:100)^2)
}

p6()
```

```{r}
bench::mark(p6())
```

### Python

```{python}
def p6(n):
    seq = range(1,n+1)
    return sum(seq)**2 - sum([math.prod(x) for x in zip(seq, seq)])
```

```{python}
# p6()
```
## Problem 7

::: {.callout-note icon=false}
## Problem
      
<p>By listing the first six prime numbers: $2, 3, 5, 7, 11$, and $13$, we can see that the $6$th prime is $13$.</p>
<p>What is the $10\,001$st prime number?</p>
:::

### Julia

```{julia}
is_divisible_by(n::Integer, q::Integer) = n % q == 0;

function find_next_prime(primes)
    n = primes[end]
    while true        
        n += 2

        not_prime = false
    
        for q ∈ primes
            not_prime = is_divisible_by(n, q)
            if not_prime
                break                
            end            
        end

        if not_prime 
            continue 
        end
    
        return(n)        
    end    
end;

function find_n_primes(n::Integer)
    primes = [2, 3]
    while length(primes) < n
        next_prime = find_next_prime(primes)
        push!(primes, next_prime)
    end

    return primes
end;

p7() = find_n_primes(10_001)[end];
p7()
```

```{julia}
using BenchmarkTools;
@benchmark p7()
```

## Problem 8

::: {.callout-note icon=false}
## Problem
      
<p>The four adjacent digits in the $1000$-digit number that have the greatest product are $9 \times 9 \times 8 \times 9 = 5832$.</p>
<p class="monospace center">
73167176531330624919225119674426574742355349194934<br>
96983520312774506326239578318016984801869478851843<br>
85861560789112949495459501737958331952853208805511<br>
12540698747158523863050715693290963295227443043557<br>
66896648950445244523161731856403098711121722383113<br>
62229893423380308135336276614282806444486645238749<br>
30358907296290491560440772390713810515859307960866<br>
70172427121883998797908792274921901699720888093776<br>
65727333001053367881220235421809751254540594752243<br>
52584907711670556013604839586446706324415722155397<br>
53697817977846174064955149290862569321978468622482<br>
83972241375657056057490261407972968652414535100474<br>
82166370484403199890008895243450658541227588666881<br>
16427171479924442928230863465674813919123162824586<br>
17866458359124566529476545682848912883142607690042<br>
24219022671055626321111109370544217506941658960408<br>
07198403850962455444362981230987879927244284909188<br>
84580156166097919133875499200524063689912560717606<br>
05886116467109405077541002256983155200055935729725<br>
71636269561882670428252483600823257530420752963450<br></p>
<p>Find the thirteen adjacent digits in the $1000$-digit number that have the greatest product. What is the value of this product?</p>
:::
      
### Julia
      
```{julia}
function p8()
  big_string = "73167176531330624919225119674426574742355349194934
      96983520312774506326239578318016984801869478851843
      85861560789112949495459501737958331952853208805511
      12540698747158523863050715693290963295227443043557
      66896648950445244523161731856403098711121722383113
      62229893423380308135336276614282806444486645238749
      30358907296290491560440772390713810515859307960866
      70172427121883998797908792274921901699720888093776
      65727333001053367881220235421809751254540594752243
      52584907711670556013604839586446706324415722155397
      53697817977846174064955149290862569321978468622482
      83972241375657056057490261407972968652414535100474
      82166370484403199890008895243450658541227588666881
      16427171479924442928230863465674813919123162824586
      17866458359124566529476545682848912883142607690042
      24219022671055626321111109370544217506941658960408
      07198403850962455444362981230987879927244284909188
      84580156166097919133875499200524063689912560717606
      05886116467109405077541002256983155200055935729725
      71636269561882670428252483600823257530420752963450" |> filter(isnumeric) # keep only numeric characters
  
  biggest_product = 0
  winner_string = ""
  amount_of_digits = 12
  
  for i in (amount_of_digits + 1):length(big_string)
    current_string = collect(big_string[i-amount_of_digits : i])
    
    p = map(x -> parse(Int32, x), current_string) |> prod
    if p > biggest_product
      biggest_product = p
      winner_string = current_string
    end
  end
  
  return reduce(*, winner_string), biggest_product
end;

p8()
```

```{julia}
using BenchmarkTools;
@benchmark p8()
```


### R

```{R}
p8 = function() {
  string = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
  
  contador2 = 14:nchar(string)
  contador1 = contador2-13
  valores = substring(string, contador1, contador2)
  maior = 0
  
  for (x in valores) {
    
    produto = prod(as.integer(unlist(strsplit(x, split = ""))))
    
    if(produto > maior) {
      
      maior = produto 
      
    }
    
  }
  
  return(maior)  
}

p8()
```

```{R}
bench::mark(p8())
```



## Problem 9

::: {.callout-note icon=false}
## Problem

<p>A Pythagorean triplet is a set of three natural numbers, $a \lt b \lt c$, for which,
$a^2 + b^2 = c^2.$</p>
<p>For example, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$.</p>
<p>There exists exactly one Pythagorean triplet for which $a + b + c = 1000$.<br>Find the product $abc$.</p>
:::

### Julia
```{julia}
function p9()
    for a ∈ 1:999
        for b ∈ 1:999            
            c = 1000 - a - b
            c >= 1 || continue
            a^2 + b^2 == c^2 || continue                        
            return a, b, c
        end
    end
end;

p9()
```

```{julia}
using BenchmarkTools;
@benchmark p9()
```

### Julia (using JuMP)
```{julia}
using JuMP; using SCIP;

function p9()
  model = Model(SCIP.Optimizer)
  set_silent(model)
  @variable(model, a >= 1, Int)
  @variable(model, b >= 1, Int)
  @variable(model, c >= 1, Int)
  @objective(model, Min, a)
  @constraint(model, pitagorean, a^2 + b^2 == c^2)
  @constraint(model, sum_1000, a + b + c == 1000)  
  optimize!(model)    
  return value(a), value(b), value(c)
end;
p9()
```

```{julia}
using BenchmarkTools;
@benchmark p9()
```

## Problem 10

::: {.callout-note icon=false}
## Problem

<p>The sum of the primes below $10$ is $2 + 3 + 5 + 7 = 17$.</p>
<p>Find the sum of all the primes below two million.</p>
:::

### Julia


```{julia}
function p10()
  sieve_of_eratosthenes(2_000_000) |> sum
end;
p10()
```


```{julia}
using BenchmarkTools;
@benchmark p10()
```
